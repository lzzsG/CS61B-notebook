---
layout: page
title: 📁Proj 0 2048
permalink: /Proj00/
nav_order: 4
parent:  L01 Intro, Hello World Java


---

实验框架https://github.com/Berkeley-CS61B/skeleton-sp21

# 项目 0：2048

## 简介

关于这个项目的高级概述可以在 https://youtu.be/Xzihuj_JZBI 找到。

本项目旨在让你熟悉 Java 以及课程中使用的各种工具，如 IntelliJ IDE 和 JUnit 单元测试编写和运行工具。虽然你会在 `proj0` 文件夹中看到许多文件和大量代码，但你的任务仅限于 `Model.java` 文件中的四个方法。

评分将*仅*基于你是否能够使程序按我们的测试要求运行，并提交指定的部分。**没有隐藏测试**。在未来的作业中，我们还会根据代码风格评分，但这不是这个项目的要求。我们仍然建议遵循我们的[style61b 指南](https://sp21.datastructur.es/materials/guides/style-guide.html)，因为它有助于创建清晰的代码，但你不会因为这个项目的代码风格而被扣分。

这个作业的规范相当长，并且有很多起始代码。我们建议你在开始编程之前先阅读完整的规范。刚开始时可能会觉得不知所措，你可能需要多次重读规范的部分内容才能完全消化，有些后面的部分可能在你完成项目的早期部分后才会完全理解。最终，我们希望你能通过这个经验获得一种成就感，能够驾驭这样一个大型任务。

## 游戏

你可能见过或玩过由 Gabriele Cirulli 编写的单人计算机游戏“2048”，该游戏基于 Veewo Studio 的早期游戏“1024”（参见他的[在线版本2048](http://gabrielecirulli.github.io/2048)）。

在这个项目中，你将构建这个游戏的核心逻辑。也就是说，我们已经编写了所有的 GUI 代码、按键处理和大量其他支架代码。你的任务是完成最重要和最有趣的部分。

具体来说，你需要填写 `Model.java` 文件中的四个方法，这些方法决定了用户按键后的行为。

游戏本身非常简单。它在一个 4×4 的方格网格上进行，每个方格可以是空的或包含一个整数的瓷砖——一个大于或等于 2 的 2 的幂。在第一次移动之前，应用程序会在最初空的棋盘上的随机方格中添加一个包含 2 或 4 的瓷砖。选择 2 或 4 是随机的，选择 2 的概率是 75%，选择 4 的概率是 25%。

然后玩家通过箭头键选择一个方向*倾斜*棋盘：北、南、东或西。所有瓷砖都会向那个方向滑动，直到运动方向上没有空位（可能一开始就没有）。一个瓷砖可能会*合并*到另一个瓷砖，玩家可以获得分数。

以下 GIF 是一些移动结果的示例。

![2048 Examples]({{ site.baseurl }}/docs/Lec01/assets/example-2048.gif)

以下是显示在上述图像中的合并发生的完整规则。

1. 两个相同值的瓷砖*合并*成一个包含初始数字两倍值的瓷砖。
2. 合并产生的瓷砖在该次倾斜中不会再次合并。例如，如果我们有 [X, 2, 2, 4]，其中 X 表示空位，并且我们将瓷砖向左移动，我们应该得到 [4, 4, X, X]，而不是 [8, X, X, X]。这是因为最左边的 4 已经是合并的一部分，因此不应再次合并。
3. 当三个相邻的瓷砖在运动方向上具有相同的数字时，前两个瓷砖在运动方向上合并，后面的瓷砖不合并。例如，如果我们有 [X, 2, 2, 2] 并将瓷砖向左移动，我们应该得到 [4, 2, X, X]，而不是 [2, 4, X, X]。

根据这些规则，如果有四个相邻的瓷砖在运动方向上具有相同的数字，它们会形成两个合并的瓷砖。例如，如果我们有 [4, 4, 4, 4]，然后我们向左移动，我们会得到 [8, 8, X, X]。这是因为根据规则 3，前两个瓷砖会合并，然后后两个瓷砖也会合并，但由于规则 2，这些合并的瓷砖（在我们的示例中是 8）在该次倾斜中不会再次合并。你会在上面的动画 GIF 中看到上述三条规则的应用，因此多次观看它以更好地理解这些规则。

为了测试你的理解，你应该完成这个 [Google 表单测验](https://forms.gle/xW74vQnK7dZAjS6eA)。这个测验不是你 61B 课程成绩的一部分。

如果倾斜没有改变棋盘状态，则不会生成新的瓷砖。否则，会在一个空方格中随机生成一个新的瓷砖。注意：你的代码不会添加任何新瓷砖！我们已经为你完成了这部分工作。

你还会注意到屏幕底部有一个“分数”字段，它会在每次移动后更新。分数不会在每次移动时都变化，只有当两个瓷砖合并时才会变化。你的代码需要更新分数。

每次两个瓷砖合并形成一个更大的瓷砖时，玩家会获得新瓷砖上的分数。当当前玩家没有可用的移动（没有任何倾斜可以改变棋盘）或移动形成包含 2048 的方格时，游戏结束。你的代码需要负责检测游戏是否结束。

“最高分”是用户在该游戏会话中达到的最高分。在游戏结束之前，它不会更新，因此在上面的动画 GIF 示例中，它始终保持为 0。

## 作业哲学和程序设计

关于本节规范的视频概述可以在 https://youtu.be/3YbIOga6ZdQ 找到。

在这个项目中，我们为你提供了大量的起始代码，其中包含许多我们尚未覆盖的 Java 语法，甚至还有一些我们课程中不会涵盖的语法。

这样做的目的是，在现实世界中，你常常会处理不完全理解的代码库，并需要进行一些修改和实验才能获得所需的结果。不要担心，当我们下周开始项目 1 时，你将有机会从头开始。

下面，我们描述了一些给定框架代码架构背后的思想，这些代码由 Paul Hilfinger 创建。理解每个细节并不重要，但你可能会发现它很有趣。

框架展示了两种常用的*设计模式*：模型-视图-控制器模式（MVC）和观察者模式。

MVC 模式将我们的问题分为三个部分：

- **模型**表示被表示和操作的主题——在这种情况下，包括棋盘游戏的状态及其修改规则。我们的模型位于 `Model`、`Side`、`Board` 和 `Tile` 类中。`Model` 的实例变量完全决定了游戏的状态。注意：你只需要修改 `Model` 类。
- 模型的**视图**，它向用户显示游戏状态。我们的视图位于 `GUI` 和 `BoardWidget` 类中。
- 游戏的**控制器**，它将用户操作转换为对模型的操作。我们的控制器主要位于 `Game` 类中，尽管它也使用 GUI 类读取按键。

MVC 模式不是 61B 的主题，你也不需要在考试或未来的项目中知道或理解这种设计模式。

第二种使用的模式是“观察者模式”。基本上，这意味着**模型**实际上不会向**视图**报告更改。相反，**视图**会注册自己作为 `Model` 对象的*观察者*。这是一个相对高级的主题，我们不会在这里提供更多信息。

现在，我们将介绍你将与之交互的不同类。

### Tile

这个类表示棋盘上的编号瓷砖。如果类型为 `Tile` 的变量为 `null`，它被视为棋盘上的空瓷砖。你不需要创建这些对象，虽然你需要理解它们，因为你将在 `Model` 类中使用它们。你需要使用的唯一方法是 `.value()`，它返回给定瓷砖的值。例如，如果 `Tile t` 对应于值为 8 的瓷砖，那么 `t.value()` 将返回 `8`。

### Side

`Side` 类是一种特殊类型的类，称为 `Enum`。枚举类似，但功能受限。具体来说，枚举只能取一组有限值中的一个。在这种情况下，我们有每一侧的值：`NORTH`、`SOUTH`、`EAST` 和 `WEST`。你不需要使用这个类的任何方法，也不需要操作实例变量。

可以使用 `Side s = Side.NORTH` 这样的语法分配枚举值。注意，与使用 `new` 关键字不同，我们只是

将 `Side` 值设置为四个值之一。同样，如果我们有一个像 `public static void printSide(Side s)` 的函数，我们可以如下调用这个函数：`printSide(Side.NORTH)`，这将传递值 `NORTH` 给函数。

如果你对了解更多关于 Java 枚举的信息感兴趣，请参阅 https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html。

### Model

这个类表示游戏的整个状态。一个 `Model` 对象表示一个 2048 游戏。它有表示棋盘状态的实例变量（即所有 `Tile` 对象的位置、分数等）以及各种方法。当你到达这个项目的第四个最终任务（编写 `tilt` 方法）时，一个挑战将是找出哪些方法和实例变量是有用的。

### Board

这个类表示瓷砖的棋盘。它有三个你将使用的方法：`setViewingPerspective`、`tile`、`move`。可以选择性地，进行实验，你可以使用 `getRandomNonNullTile`。

**你只会在这个作业中编辑 `Model.java` 文件。** Gradescope 只会获取你的 `Model.java` 文件并使用其他文件的框架版本，因此如果你例如编辑了 `Tile.java`，Gradescope 将不会识别这些更改。

## 开始

**首先，确保你已经完成了[实验 1](https://sp21.datastructur.es/materials/lab/lab1/lab1)**。如果你没有完成实验 1 要求的所有必要设置，你将无法进行项目。

### 获取框架文件

首先，确保你的存储库中的所有内容都已正确更新和检查。在你开始之前，运行以下命令：

```
git status
```

在你的 `sp21-s***` 目录中执行时，应该报告目录是干净的，没有需要添加和提交的未跟踪文件。如果有，只需添加和提交。

*绝不要*在没有这样做的情况下开始一个新项目。

要获取框架文件，你应该使用以下命令：

```bash
git pull skeleton master
```

在你的 `sp21-s***` 目录中。你会看到一个包含所有框架代码的 `proj0` 文件夹现在在你的学生存储库中。

在极不可能的情况下，如果我们必须更新框架，你可以使用相同的命令来更新项目中的更改。

### 重新开始：框架

如果你发现自己希望完全重新开始而不是尝试使当前代码工作，这是可能的！只需在你的 `sp21-s***` 目录中运行以下命令：

```bash
git checkout skeleton/master -- proj0
```

注意：此命令将删除 `proj0` 目录中所有未提交的更改。因此，如果你认为你可能需要当前代码，只需在运行此命令之前进行一次提交，然后你可以使用类似命令将 `proj0` 目录恢复到你刚刚提交的状态。

### IntelliJ 设置

现在，让我们在 IntelliJ 中打开这些文件。首先，启动 IntelliJ。它会显示你最近项目的列表，但由于你还没有开始这个作业，因此它不会在列表中。要打开项目，点击应用程序窗口右上角的“打开”按钮，这将调出你的操作系统的文件浏览器。导航到学生存储库中的 `proj0` 文件夹，然后点击打开：

![打开项目]({{ site.baseurl }}/docs/Lec01/assets/intellij-pre-open.png)

![打开项目]({{ site.baseurl }}/docs/Lec01/assets/intellij-open.png)

在屏幕的左上角，你会看到 `proj0` 目录中的文件/文件夹列表。如果没有，点击 `proj0` 文件夹上的向下箭头，这将展开文件夹。它应该看起来像这样：

![列出文件夹]({{ site.baseurl }}/docs/Lec01/assets/list-files.png)

`.idea` 文件夹是 IntelliJ 生成的用于存储杂项设置的文件夹。你可以忽略这个文件夹。

`game2048` 文件夹是所有 Java 文件的源代码。你需要做的一切都在这个文件夹中。

`javalib` 文件夹是一个 Java 库。它包含三个 `.jar` 文件，这些文件是我们要使用的预编译文件。这三个文件允许我们运行 JUnit 和一些 UC Berkeley 特定的东西来在漂亮的窗口中呈现游戏。

IntelliJ 通常足够智能，可以为你设置其余内容，但如果你的 IntelliJ 应用程序遇到困难，我们将逐步进行设置。

首先，让我们告诉 IntelliJ 我们正在使用 Java 15。导航到文件 > 项目结构：

![打开项目结构]({{ site.baseurl }}/docs/Lec01/assets/opening-project-structure.png)

点击“编辑”按钮左侧的框，这将允许你选择 JDK（即你的 Java 版本）。

![Java 15]({{ site.baseurl }}/docs/Lec01/assets/java15.png)

现在，我们将告诉 IntelliJ 我们要使用 `javalib` 文件夹中的那些 `.jar` 文件。仍然在项目结构中，在左侧点击项目设置的“库”部分。如果你看到 `javalib` 已经添加，则不需要做任何操作。否则，我们将点击“+”按钮，然后点击“Java”，这将启动操作系统的文件浏览器，然后我们点击 `javalib` 文件夹。然后，在屏幕的右下角，点击“应用”然后点击蓝色的“确定”按钮。

总的来说，设置应该看起来像这样（对不起模糊的图片）：

![IntelliJ 设置]({{ site.baseurl }}/docs/Lec01/assets/intellij-setup.gif)

确保设置正确，打开 `game2048` 文件夹，右键点击 `Main` Java 文件：你会看到一些选项，但我们关心的是绿色的“运行 Main.main()”按钮。它应该看起来像下面的图片：

![运行 Main]({{ site.baseurl }}/docs/Lec01/assets/run-main.png)

点击它来启动 2048 游戏。这将启动一个带有空白棋盘的新窗口。现在先关闭窗口，我们将在本规范的“主要任务：构建游戏逻辑”部分回来。

如果没有弹出任何窗口，说明你的设置不正确。你应该重新执行上述步骤以确保没有遗漏，但不要在此上花费超过 10 分钟。最好在助教的帮助下解决设置问题，意味着你应该在 Ed 上发帖或去办公时间。如果你在 Ed 上发帖，你需要告诉我们你做过/尝试过的**所有**事情，以便我们能清楚地了解错误是什么。包括所有内容的截图，尤其是任何错误信息。

你可能遇到的一个奇怪问题是代码编译和运行正常，但在 IntelliJ 中仍然有红色下划线。转到 `Model` 类，找到 `addTile` 方法。这是我们提供的方法，但你可能会看到 `tile` 变量有红色下划线和以下错误信息：

![IntelliJ 错误]({{ site.baseurl }}/docs/Lec01/assets/intellij-error.png)

但我们知道显然这是正确的，因为 1). 代码运行了，2). 这是起始代码！虽然 IntelliJ 非常强大，但有时它确实会出错。要解决这个问题，你应该转到文件 > 无效缓存/重启，然后在随后的窗口中点击“无效并重启”

![无效缓存]({{ site.baseurl }}/docs/Lec01/assets/invalidate-caches.png)

这将花费一两分钟，因为 IntelliJ 正在重新索引你的 JDK 并从头设置你的项目。完成后，你应该在源文件中看不到红色下划线。

除非上述设置正常，否则你将无法进行项目，因此尽快进行设置是你的首要任务。

## 你的任务

在这个项目中，你的工作是修改和完成 `Model` 类，具体来说是实现 `emptySpaceExists`、`maxTileExists`、`atLeastOneMoveExists` 和 `tilt` 方法。其他部分已经为你实现。我们建议按以下顺序完成这些方法。前两个方法相对简单。第三个方法（`atLeastOneMoveExists`）比较难，最后一个方法 `tilt` 可能非常困难。我们预计完成 `tilt` 方法需要 3 到 10 小时。前三个方法处理游戏结束的条件，最后一个方法 `tilt` 将在用户按键后修改棋盘。你可以阅读 `checkGameOver` 方法的简短主体，以了解你的方法将如何用于检查游戏是否结束。

让我们先看看前三个方法：

### public static boolean emptySpaceExists(Board b)

这个方法应该返回 `true`，如果给定棋盘中的任何瓷砖为 `null`。**你不应该修改 Board.java 文件**。对于这个方法，你将需要使用 `Board` 类的 `tile(int col, int row)` 和 `size()` 方法，不需要使用其他方法。

注意：我们使用了特殊关键字 `private` 设计了 `Board` 类，它禁止你直接使用 `Board` 的实例变量。例如，如果你尝试访问 `b.values[0][0]`，这是行不通的。这是件好事！它强迫你学习使用 `tile` 方法，这是你在整个项目中都会使用的方法。

尝试打开 `TestEmptySpace.java` 文件夹，运行测试。你会看到 6 个测试失败，2 个测试通过。在你正确编写 `emptySpaceExists` 方法后，`TestEmptySpace` 中的所有 8 个测试都应该通过。

如何开始编写这个方法的快速概述可以在 [这个视频](https://youtu.be/13rdFndFNXc) 中找到。

### public static boolean maxTileExists(Board b)

如果棋盘中的任何瓷砖等于获胜瓷砖值 2048，这个方法应该返回 `true`。注意，不要在代码中硬编码常量 2048，而是使用 `Model` 类中的常量 `MAX_PIECE`。换句话说，不要使用 `if (x == 2048)`，而是使用 `if (x == MAX_PIECE)`。

在代码中留下硬编码的数字（如 `2048`）是一种不好的编程习惯，有时被称为“魔法数字”。这种魔法数字的危险在于，如果你在代码的一部分中更改它们而不在另一部分中更改，你可能会得到意想不到的结果。通过使用像 `MAX_PIECE` 这样的变量，你可以确保它们都一起更改。

编写完这个方法后，`TestMaxTileExists.java` 中的测试应该通过。

### public static boolean atLeastOneMoveExists(Board b)

这个方法比较有挑战性。如果有任何有效的移动，这个方法应该返回 `true`。所谓“有效移动”，是指如果在玩 2048 时用户按下的按钮（向上、向下、向左或向右）导致至少一个瓷砖移动，那么这样的按键被视为有效移动。

有效移动有两种情况：

1. 棋盘上至少有一个空位。
2. 有两个相邻的瓷砖具有相同的值。

例如，对于下面的棋盘，我们应该返回 `true`，因为至少有一个空位。

```
|   2|    |   2|    |
|   4|   4|   2|   2|
|    |   4|    |    |
|   2|   4|   4|   8|
```

对于下面的棋盘，我们应该返回 `false`。无论你按下 2048 的哪个按钮，什么也不会发生，即没有两个相邻的瓷砖具有相同的值。

```
|   2|   4|   2|   4|
|  16|   2|   4|   2|
|   2|   4|   2|   4|
|   4|   2|   4|   2|
```

对于下面的棋盘，我们应该返回 `true`，因为向右或向左移动会合并两个 64 的瓷砖，向上或向下移动会合并 32 的瓷砖。换句话说，存在至少两个相邻的瓷砖具有相同的值。

```
|   2|   4|  64|  64|
|  16|   2|   4|   8|
|   2|   4|   2|  32|
|   4|   2|   4|  32|
```

编写完这个方法后，`TestAtLeastOneMoveExists.java` 中的测试应该通过。

## 主要任务：构建游戏逻辑

作业的第四个也是最后一个部分是实现 `tilt` 方法。你应该在通过 `TestEmptySpace`、`TestMaxTileExists` 和 `TestAtLeastOneMoveExists` 中的所有测试后再开始编写这个方法。

计算机科学本质上是关于一件事：管理复杂性。编写 `tilt` 方法是一个丰富的体验，它将给你一个机会去尝试这一点。我要警告你，这可能会是一个令人沮丧的经历。你很可能会尝试几种方法，但最终都失败了，之后你需要重新开始。

在开始讨论 `tilt` 方法的工作原理之前，让我们先试运行游戏。

打开 `Main` 类并点击运行按钮。你应该会看到游戏弹出。尝试按下箭头键。你会发现什么也没有发生。这是因为你还没有实现 `tilt` 方法。当你完成编写 `tilt` 方法后，你将能够玩游戏。

### public boolean tilt(Side side)

`tilt` 方法负责实际移动所有的瓷砖。例如，如果我们有如下所示的棋盘：

```
|   2|    |   2|    |
|   4|   4|   2|   2|
|    |   4|    |    |
|   2|   4|   4|   8|
```

按上键后，`tilt` 方法将修改 `board` 实例变量，使游戏状态变为：

```
|   2|   8|   4|   2|
|   4|   4|   4|   8|
|   2|    |    |    |
|    |    |    |    |
```

除了修改棋盘，还必须完成以下两件事：

1. `score` 实例变量必须更新，以反映所有瓷砖合并的总值（如果有的话）。对于上述示例，我们将两个 4 合并为一个 8，将两个 2 合并为一个 4，因此分数应增加 8 + 4 = 12。
2. 如果棋盘有任何变化，我们必须将 `changed` **局部变量** 设置为 `true`。这是因为在 `tilt` 方法的框架代码结尾，你会看到我们调用了 `setChanged()` 方法：这通知 GUI 有东西需要绘制。你不会自己调用 `setChanged`：只需修改 `changed` 局部变量。

棋盘上的所有瓷砖移动都必须使用 `Board` 类提供的 `move` 方法完成。所有棋盘瓷砖必须使用 `Board` 类提供的 `tile` 方法访问。**由于 GUI 实现中的一些细节，你应该在每次调用 `tilt` 时仅对给定瓷砖调用一次 `move`**。我们将在本文档的提示部分进一步讨论这一约束。

如何开始编写这个方法的快速概述可以在 [这个视频](https://youtu.be/abFbbK1QY2k) 中找到。

## 提示

我们强烈建议先只考虑向上的方向，即当提供的 `side` 参数等于 `Side.NORTH` 时。为支持你完成这一点，我们提供了一个 `TestUpOnly` 类，其中有四个测试：`testUpNoMerge`、`testUpBasicMerge`、`testUpTripleMerge` 和 `testUpTrickyMerge`。你会注意到这些测试只涉及一次向上的移动。

在考虑如何实现向上方向时，请考虑以下内容：

在给定的列中，最顶行（第 3 行）的瓷砖保持不变。如果上方的空间是空的或具有相同的值，则第 2 行的瓷砖可以向上移动。换句话说，在迭代行时，从第 3 行向下迭代是安全的，因为瓷砖在移动一次后不会再次移动。

虽然这听起来并不难，但实际上非常难。准备好拿出笔记本，列出大量示例。努力编写优雅的代码，尽管在这个问题上实现优雅是很难的。我们强烈建议创建一个或多个辅助方法来保持代码的简洁。例如，你可以有一个辅助函数来处理

棋盘的一列，因为每一列是独立处理的。或者你可以有一个辅助函数返回期望的行值。

提醒：你应该只对给定的瓷砖调用一次 `move`。换句话说，假设你有如下棋盘并按上键。

```
|    |    |    |    |
|    |    |    |    |
|    |    |    |    |
|    |    |    |   2|
```

一种完成此操作的方法如下：

```java
Tile t = board.tile(3, 0)
board.move(3, 1, t);
board.move(3, 2, t);
board.move(3, 3, t);
setChanged();
return true;
```

然而，GUI 会混淆，因为同一瓷砖不应该在一次 `setChanged` 调用中移动多次。相反，你需要通过一次 `move` 调用完成整个移动，例如：

```java
Tile t = board.tile(3, 0)
board.move(3, 3, t);
```

在某种意义上，难点在于确定每个瓷砖最终应该在哪一行。

为了测试你的理解，你应该完成这个 [Google 表单测验](https://forms.gle/pubhRx4fxYnPTGNX8)。这个测验（以及接下来的测验）完全是可选的（即不评分），但**强烈建议**，因为它可以找出你对游戏机制的任何概念性误解。你可以多次尝试这个测验。

要知道何时更新分数，请注意 `board.move(c, r, t)` 方法在将瓷砖 `t` 移动到列 `c` 和行 `r` 时，如果替换了一个现有瓷砖（即你进行了合并操作），则返回 `true`。

看起来更糟糕的是，即使你让 `tilt` 在向上方向上工作，你还需要对其他三个方向做同样的事情。如果你天真地进行处理，你会得到大量重复的、略有修改的代码，并有很多机会引入模糊的错误。

对于这个问题，我们给出了一个干净的解决方案。这将允许你只用两行额外代码处理其他三个方向！具体来说，`Board` 类有一个 `setViewingPerspective(Side s)` 方法，它将改变 `tile` 和 `move` 方法的行为，使它们*表现得像给定的方向是北*。

例如，考虑下面的棋盘：

```
|    |    |    |    |
|  16|    |  16|    |
|    |    |    |    |
|    |    |    |   2|
```

如果我们调用 `board.tile(0, 2)`，我们会得到 `16`，因为 16 在列 0，第 2 行。如果我们调用 `board.setViewingPerspective(s)`，其中 `s` 是 `WEST`，则棋盘将表现得像西是北一样，即你的头向左转 90 度，如下所示：

```
|    |    |  16|    |
|    |    |    |    |
|    |    |  16|    |
|   2|    |    |    |
```

换句话说，我们之前的 `16` 将位于 `board.tile(2, 3)`。如果我们用正确实现的 `tilt` 调用 `board.tilt(Side.NORTH)`，棋盘将变为：

```
|   2|    |  32|    |
|    |    |    |    |
|    |    |    |    |
|    |    |    |    |
```

要使棋盘恢复到原来的视角，我们只需调用 `board.setViewingPerspective(Side.NORTH)`，这将使棋盘表现得像 `NORTH` 是北。如果我们这样做，棋盘现在将表现得像是：

```
|    |    |    |    |
|  32|    |    |    |
|    |    |    |    |
|   2|    |    |    |
```

注意，这和你将原始棋盘向 `WEST` 滑动瓷砖是一样的。

重要提示：确保在完成 `tilt` 调用之前使用 `board.setViewingPerspective` 将视角设置回 `Side.NORTH`，否则会发生奇怪的事情。

为了测试你的理解，尝试这个第三个也是最后一个 [Google 表单测验](https://forms.gle/AGrhEFbwfMJ7qwaB6)。你可以多次尝试这个测验。

## 测试

虽然我们期望你将来能够自己测试程序，但对于这个项目，我们已经为你提供了完整的测试套件。

测试分布在 5 个文件中：`TestEmptySpace`、`TestMaxTileExists`、`TestAtLeastOneMoveExists`、`TestUpOnly` 和 `TestModel`。每个文件测试代码的特定部分，除了 `TestModel`，它测试你编写的所有内容如何协调工作。这样的测试称为*集成测试*，在测试中非常重要。虽然单元测试在孤立的情况下运行，但集成测试在一起运行，旨在捕捉你编写的不同函数之间交互引起的模糊错误。

所以，在通过其他测试之前，不要尝试调试 `TestModel`！事实上，我们讨论测试的顺序就是你应该尝试它们的顺序。

现在我们将看看这些测试中的每一个，并向你展示如何阅读错误消息。

### TestEmptySpace

这些测试将检查你的 `emptySpaceExists` 方法的正确性。如果你未通过某个测试，错误消息如下所示：

![TestEmptySpace 全部失败]({{ site.baseurl }}/docs/Lec01/assets/test-empty-space-all-fail.png)

在左侧，你会看到所有运行的测试列表。黄色 X 表示我们未通过测试，绿色勾号表示我们通过了测试。在右侧，你会看到一些有用的错误消息。要查看单个测试及其错误消息，点击左侧的测试。例如，我们要查看 `testCompletelyEmpty` 测试。

![testCompletelyEmpty]({{ site.baseurl }}/docs/Lec01/assets/test-completely-empty.png)

右侧是此测试的隔离错误消息。顶部有一条有用的消息：“Board is full of empty space”，后面是棋盘的字符串表示。你会看到它显然是空的，但我们的 `emptySpaceExists` 方法返回 `false`，导致此测试失败。测试代码顶部的 javadoc 注释也包含一些有用的信息，以防你未通过测试。

### TestMaxTileExists

这些测试将检查你的 `maxTileExists` 方法的正确性。错误消息将类似于 `TestEmptySpace`，你仍然可以点击每个单独的测试来单独查看它们。记住你的 `maxTileExists` 方法**只**应该查找最大瓷砖，而不是其他任何东西（即不应该查找空位）。如果你的方法这样做，你将无法通过所有这些测试。

### TestAtLeastOneMoveExists

这些测试将检查你的 `atLeastOneMoveExists` 方法的正确性。错误消息类似于上面两个。由于 `atLeastOneMoveExists` 方法依赖于 `emptySpaceExists` 方法，你在通过 `TestEmptySpace` 中的所有测试之前，不应该期望通过这些测试。

### TestUpOnly

这些测试将检查你的 `tilt` 方法的正确性，但仅在向上（`Side.NORTH`）方向。这些测试的错误消息有所不同，所以让我们看看其中一个。假设我们运行所有测试，注意到我们未通过 `testUpTrickyMerge` 测试。点击该测试后，我们会看到：

![testUpTrickyMerge 错误消息]({{ site.baseurl }}/docs/Lec01/assets/test-up-error-msg.png)

第一行告诉我们倾斜的方向（对于这些测试，它总是北），然后是倾斜前棋盘的样子，然后是我们期望的棋盘样子，最后是实际的棋盘样子。

你会看到我们在一次 `tilt` 调用中合并了一个瓷砖两次，导致一个值为 8 的瓷砖而不是两个值为 4 的瓷砖。因此，正如你在棋盘表示的底部所见，我们的 `score` 也是错误的。

对于其他测试，可能一开始不容易注意到期望和实际棋盘之间的差异；对于这些测试，你可以点击错误消息底部的蓝色“Click to see difference”文本，以在单独的窗口中获得期望（左侧）和实际（右侧）棋盘的并排比较。以下是此测试的样子：

![testUpTrickyMerge 比较]({{ site.baseurl }}/docs/Lec01/assets/comparison.png)

调试这些可能有点棘手，因为很难判断你做错了什么。首先，你应该确定你违反了哪条规则。在这种情况下，我们可以看到是规则 2，因为一个瓷砖在一次倾斜中合并了多次。这些方法上的 javadoc 注释是很好的资源，因为它们

具体列出了它们在测试什么规则/配置。你也可以通过查看之前和之后的棋盘来找出你违反了什么规则。然后，最棘手的部分：重构现有代码以正确考虑该规则。我们建议用笔和纸写出你的代码步骤，以便你首先理解为什么你的棋盘看起来如此，然后想出解决方案。这些测试只调用一次 `tilt`，所以你不需要担心调试多次调用 `tilt`。

### TestModel

这些测试将检查所有内容的正确性。大多数这些测试类似于 `TestUpOnly` 中的测试，因为它们只调用一次 `tilt`，但我们也有 `gameOver` 的测试（它们一起测试你的 `emptySpaceExists`、`maxTileExists` 和 `atLeastOneMoveExists` 方法）以及一系列多次调用 `tilt` 的测试。

这些测试的错误消息与 `TestUpOnly` 中的错误消息完全相同，javadoc 注释在弄清测试内容方面同样有用。

不用担心这些测试的实际代码：你不需要理解或修改这些代码，虽然你可以阅读并了解测试编写的工作原理，甚至如果你感到非常雄心勃勃，可以添加一些自己的测试。

## 评分

一个完整评分的项目将通过我们提供的所有单元测试。记住，**没有隐藏测试**，所以如果你通过了所有这些测试，那么你就完成了一个完整评分的项目！

在 Gradescope 上，一些测试的权重略有不同，所以如果你未通过某些测试，你的分数百分比将是不同的比例（可能更高）。

这是因为这个项目的某些部分比其他部分更难，我们知道这是许多学生第一次使用 Java，所以我们在设计项目时考虑到了这一点。

以下是不同完成程度下你在这个项目中的得分百分比：

1. 只实现 `emptySpaceExists` 或 `maxTileExists`：约 27%
2. 实现除 `tilt` 以外的所有内容：约 47%
3. 实现所有内容，但 `tilt` 只在向上方向工作：约 68%
4. 实现所有内容，但没有合并：约 64%
5. 实现所有内容，但没有处理合并规则 2：约 93%

你会注意到，处理合并规则 2 只占项目的约 7%。这是因为这是一个难以处理的规则，占游戏本身的很小一部分，所以我们相应地加权。

## 额外奖励

在截止日期前一天（即星期四晚上 11:59 前）提交最终提交的同学将获得 2 分额外奖励。“最终提交”是指在 Gradescope 上激活的提交，所以你可以在截止日期后提交更多，但额外奖励分只适用于在星期四晚上 11:59 前的激活提交。分数将在截止日期后应用，因此你不会在项目截止之前看到它们。

## 提交和版本控制

重要的是你要*频繁*将工作提交到你的存储库。版本控制是一个强大的工具，可以在你搞砸某件事情或你的狗吃掉你的项目时救你一命，但你必须经常使用它才能有用。随时提交也没关系；Git 只保存已更改的内容，即使它表现得像是对整个项目进行了快照。

`git status` 命令将告诉你自上次提交以来你修改、删除或可能添加了哪些文件。它还会告诉你还有多少内容没有发送到你的 GitHub 存储库。

典型的命令如下：

```bash
git status                          # 查看需要添加或提交的内容
git add <filepath>                  # 添加或暂存任何修改的文件
git commit -m "提交信息"             # 提交更改
git push
```

然后你可以继续进行项目，直到你准备再次提交和推送代码，在这种情况下，你将重复上述步骤。为了让你更轻松地恢复旧版本的代码，我们建议你养成频繁提交并使用信息丰富的提交信息的习惯。我们建议你每次添加大量代码或达到某个里程碑时提交（例如通过新的测试）。

一旦你将代码推送到 GitHub（即运行 `git push`），你可以进入 Gradescope，找到 `proj0` 作业并在此提交代码。请记住，Gradescope 使用的代码版本是你推送的最新提交，因此如果你在 Gradescope 上提交之前没有运行 `git push`，将测试旧代码而不是你电脑上的最新代码。

## 获取帮助

虽然一些挣扎和调试是正常的，甚至是健康的，但如果你发现自己在做了上述所有建议后数小时毫无进展，请寻求助教的帮助！

在 CS 61B 中有两种获取帮助的方式：去办公时间或在 Ed 上发帖以便助教或其他学生帮助你解锁。

记住助教在办公时间每位学生最多花费 10 分钟。为了加快速度，我们要求你带来一个清晰的问题，可以向助教表达，而不仅仅是告诉我们一个测试没有通过。例如，如果测试没有通过，找出哪个部分没有通过以及为什么有差异。也许是 `score` 没有正确更新，或者可能是合并不如预期。这有助于加快速度，甚至可能让你找到自己的错误。

如果你在 Ed 上发帖，请阅读我们的[Ed 政策](https://sp21.datastructur.es/materials/guides/ed-policies)，以确保你没有意外地发布部分解决方案，从而违反我们的学术诚信政策。否则，我们欢迎在我们的 mega 线程中进行建设性讨论。记住在发布跟帖之前搜索你的问题，因为许多学生有非常相似的错误！
