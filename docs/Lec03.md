---
layout: page
title: L03 Testing
permalink: /Lec03/
nav_order: 3
has_children: true


---

# L03 Testing

## 编写测试以提高代码质量

本部分通过实际编写测试的例子，探讨了如何在编程课程中重构思维模式，以便更好地适应真实世界的编程需求。具体包括如何自行验证代码正确性，而非依赖自动评分系统。

### 课程目标

课程的主要目标之一是重新配置学生的大脑，使其能够以一种更符合现实世界需求的方式思考编程问题。这不仅涉及到语法和编程技巧的学习，还包括如何管理复杂性和编写测试。

### 使用测试管理复杂性

在实际编程中，与其依赖某种神秘的自动评分工具，不如自己编写测试来验证代码的正确性。这种方法可以帮助程序员建立起对自己代码的信心，尽管这一过程并不是百分之百准确，但它是一个极为有用的工具，能够显著提高代码的可靠性。

### 测试的实际编写

通过一个实际例子，即编写一个排序方法，并为之编写测试，展示了如何在实际中应用测试。在这个例子中，我们首先定义了一个排序函数，然后在编写函数逻辑之前，先编写了测试。这种“测试优先”的方法有助于确保编写的代码能够满足预定的需求。

### 代码与测试的具体实现

具体到这个排序函数的实现，我们通过以下步骤进行：

1. **定义输入和期望输出**：定义一个字符串数组作为输入，并设置一个预期的输出数组，即排序后的数组。
2. **编写测试逻辑**：测试逻辑包括调用排序函数对输入数组进行排序，然后比较排序后的数组与预期输出是否一致。
3. **处理测试中的问题**：在测试过程中，如果发现排序函数没有按预期工作，测试应能准确指出问题所在。

### 测试中的常见错误和解决方法

在测试实现中，一个常见的错误是使用 `!=` 来比较数组内容，这实际上比较的是数组对象的引用而非内容。正确的方法是使用 `Arrays.equals()` 来比较两个数组的内容。此外，如果测试失败，应提供详细的错误信息，帮助定位问题。

## Ad Hoc 测试

在上一个视频中，我们进行了即席测试，即基于已知知识编写了专用于测试排序方法的代码。这种方式的确很麻烦，因为写出类似的代码很单调乏味。想象一下，如果要为所有功能都这么做，测试工作似乎就是一项我们非常想要外包的工作。

## JUnit 库的介绍

接下来，我将展示如何使用 JUnit 库来省去编写上述代码的麻烦，避免类似之前出现的一些小而微妙的错误，并使我们的代码变得更简单。原本一大段代码，现在我可以用这样一行代码来替代：
```java
org.junit.Assert.assertEquals(expected, input);
```
之后，删除那一段代码，运行时，它会显示出错误，但其实这行代码的效果与我们之前的循环完全相同，而且这段代码几乎不会出错。

## 弃用的方法

值得注意的是，这里的 `assertEquals` 方法被标记为弃用。如果你不熟悉“弃用”这个词，它在编程中意味着某个功能虽然还被支持，但不推荐使用。因此，我们应该使用 `assertArrayEquals` 替代它。这表明，即使库的作者标记了旧方法，但通常出于兼容性考虑，他们不会立即移除这些方法。

## 选择排序算法介绍

为了编写排序方法，我将介绍一种叫做选择排序的技术。其工作原理是：首先找到数组中最小的元素，并将其移到数组的前端。然后，对剩余的元素重复这一过程，直到整个数组被排序。这种方法简单有效。

## 实现选择排序

现在我们明白了选择排序的原理，就可以开始实现它了。这个过程我会分步骤展示，但主要还是在视频中讲解，不会详细体现在幻灯片中。我会使用多个辅助方法来分解排序方法，例如，创建一个返回最小字符串的 `findSmallest` 方法。按照本讲的理念，我会先写测试代码。

## 编写测试方法

首先，我们将编写测试方法 `testFindSmallest`，来测试 `findSmallest` 方法。尽管 `findSmallest` 方法应该是私有的，但由于测试代码位于不同的类中，无法直接访问。为解决这个问题，最简单的方法是将其改为公开方法。这种做法虽然直接，但在设计上并不优雅，因为这意味着我们将把 `findSmallest` 方法暴露给外界，这并不是排序类的主要功能。我们会在课程的后续部分探讨其他替代方案，并在教科书中进行讨论。

## 测试实现和调整

通过 JUnit 进行测试非常简单，我们只需在测试方法中调用 `findSmallest`，然后使用 `assertEquals` 来比较预期结果和实际结果。如果测试未通过，说明存在问题，这反而是好事，因为它帮助我们发现错误。在这个例子中，我们发现虽然方法返回了一个假值，但它恰好是正确的答案，这提示我们需要更改假值以确保测试的有效性。

## 解决 Java 字符串比较问题

在实现 `findSmallest` 方法时，我们遇到了一个问题：Java 中不能直接使用小于号（`<`）来比较字符串。正确的做法是使用字符串的 `compareTo` 方法。如果你是学生可能不清楚 `compareTo` 方法的工作原理，通常的解决方案是搜索如何在 Java 中比较字符串。`compareTo` 方法会根据字典顺序返回一个整数，表示两个字符串的比较结果。如果返回值小于零，表示第一个字符串小于第二个字符串。

## 增强测试以确保可靠性

尽管初步的测试通过了，但作为初学者，我们可能对测试的可靠性不够信任。因此，我们可以增加更多的测试用例，以确保 `findSmallest` 方法能在更多情况下正确工作。通过不断增强测试，我们可以提高对程序正确性的信心，这对于开发者来说是非常重要的。

## 实现交换辅助方法

在完成找到数组中最小元素的方法后，我们接下来要实现的是交换数组中两个元素的位置。为此，我将编写一个 `swap` 辅助方法，该方法接受一个数组和两个索引作为参数，并交换这两个索引位置的元素。最初，我可能会简单地尝试如下实现：
```java
x[a] = x[b];
x[b] = x[a];
```
尽管这看起来很直观，但它实际上是有错误的，因为这种实现方式会导致元素的覆盖。

## 测试交换功能

为了展示测试的重要性，我们将为 `swap` 方法编写测试。假设输入数组是 `["i", "have", "an", "egg"]`，我们尝试交换索引0和2的元素，预期的结果应该是 `["an", "have", "i", "egg"]`。我们将调用 `swap` 方法并使用 `assertEquals` 断言预期结果与实际结果相符。运行测试后，我们发现测试未通过，这提示我们 `swap` 方法中存在问题。

## 使用调试器定位问题

如果我们没有立即看出错误，可以使用调试器来逐步执行代码，观察变量的变化。通过调试，我们可以发现，在没有使用临时存储的情况下，尝试交换两个元素实际上会导致一个元素被另一个元素覆盖。为了解决这个问题，我们需要引入一个临时变量：
```java
String temp = x[a];
x[a] = x[b];
x[b] = temp;
```
这样修改后，再次运行测试，我们可以看到测试通过了，验证了我们的修复是成功的。

## 调整辅助方法以适应API

在尝试将 `findSmallest` 和 `swap` 方法组合使用时，我们遇到了一个问题：`findSmallest` 返回了最小元素的字符串，而 `swap` 需要的是索引。这种 API 不匹配提示我们需要调整这些方法以确保它们可以协同工作。最自然的解决方案是修改 `findSmallest` 方法，使其返回最小元素的索引而非元素本身。

## 测试和验证调整

修改 `findSmallest` 方法后，我们需要相应地调整测试以确保它返回正确的索引。此外，我们还需要验证这一变更没有引入新的问题。通过运行测试，我们可以确认所有更改均按预期工作，增强了我们对代码的信心。

总之，通过引入测试和使用调试器，我们不仅能够识别并修复问题，还能在进行重要更改时确保代码的健壁性和正确性。这些工具为我们的开发过程提供了有力的支持。

## 反思已取得的成就

到目前为止，我们完成了很多工作。首先，我们编写了 `testSort` 测试，然后构建了 `sort` 方法的基本框架，并在此过程中插入了一些注释。接下来，由于我们知道需要一个 `findSmallest` 方法，我们编写了 `testFindSmallest` 测试，然后实际创建了这个方法。在这个过程中，我们使用了 Google 来解决如何在 Java 中比较字符串的问题，这展示了利用搜索引擎查找编程问题解决方案的重要技能。

## 开发辅助方法和调整

然后，我们继续开发了 `swap` 方法，并为其编写了测试。在尝试将两个辅助方法——`findSmallest` 和 `swap`——结合使用时，我们发现了一个错误，需要修改 `findSmallest` 方法，并调整了相应的测试。此外，我们还利用调试器修复了 `swap` 方法中的一个错误。

## 考虑递归调用的实现

我们的代码目前可以找到数组中最小的元素并将其放在前面，但我们还需要对数组的剩余部分进行排序。这就引出了可能需要进行递归调用的想法。我希望你能思考这种递归调用可能是什么样的。这里有一个限制：你不能改变 `sort` 方法的声明，这是解决这个问题的一部分挑战。

## Java 中的数组操作限制

在像 Python 这样的语言中，你可能会尝试使用类似数组切片的功能来排序数组的剩余部分。但在 Java 中，你不能在数组中进行这样的操作。你获取的是整个数组，而不能直接访问数组的中间部分或对其进行子索引。

## 创建一个特定索引开始的排序辅助方法

为了解决这个问题，我们可以创建一个新的辅助方法，该方法从数组的特定索引开始进行排序。这个方法将是私有的，可能需要公开以便进行测试。该方法的实现将包括找到最小项、执行交换（注意，交换发生在我们开始排序的位置，而不是位置零），然后对数组的其余部分进行排序。

## 结合所有步骤

最后，我们需要确保这些步骤能够整合在一起工作。公共面向的方法，即 `sort` 方法，将只需要发起正确的初始调用，即从位置零开始排序整个数组。这样，每个步骤都能顺利过渡到下一个步骤，实现整个数组的排序。

## 代码整理和调试

我们开始对代码进行一些整理，移除不相关的注释和多余的代码行。接下来，为了确保代码的正确性，我们运行了 `testSort` 测试，不幸的是发现了问题——出现了数组越界的错误。

## 诊断数组越界问题

出现数组越界错误表明我们访问了不存在的数组索引。为了更好地理解问题发生的上下文，我设置了一个条件断点来查看当数组索引 `a` 等于4时的情况。通过这种方式，我们能够直接定位到问题发生的地点，进而发现问题的根源是递归调用中 `start` 变量过大。

## 忘记基本情况的递归方法

在递归的实现中，我们忘记了添加基本情况，即当 `start` 等于数组长度时应该停止递归。添加了这个基本情况后，我们再次运行测试，但测试依然未通过，表明还存在其他问题。

## 进一步的调试和问题定位

现在，我们需要进一步诊断问题。当面对复杂项目中的问题时，能够有效地解决问题是非常重要的技能。我会通过逐步跟踪来查看每次交换操作，使用可视化工具来直观地查看数组的变化，并观察每一步操作是否如预期执行。

## 观察错误的交换操作

在观察交换操作时，我们发现第一次交换正常，但在后续的交换中发现了错误。特别是在期望将 `egg` 移动到索引1的位置时，却发现 `have` 和 `an` 被交换了位置，这与我们的预期不符。

## 识别和修复问题

这种发现让我们意识到在执行排序算法的某个部分时逻辑出现了错误。通过进一步的调试，我们注意到 `smallestIndex` 的值不正确，它应该指向当前子数组中最小元素的索引，而不是整个数组。这种错误的索引计算导致了错误的交换。

## 逐步验证和调整

我决定再次逐步通过代码，特别是从第一次正确的交换后开始，仔细检查每个变量的状态和每个函数的输出。这样做可以帮助我们准确地识别问题所在，并验证我们的修复是否有效。



## 调试过程中定位问题

在继续调试时，我们注意到 `findSmallest` 方法返回的最小索引值错误。我预期的结果是索引3，但实际上返回了0。这迫使我们深入 `findSmallest` 方法的实现来查看问题所在。

## 发现设计缺陷

在仔细审视 `findSmallest` 方法后，我们发现了一个设计上的重大缺陷。原始的 `findSmallest` 方法始终从数组的起始位置寻找最小的字符串，而没有考虑到我们需要从一个特定的起点开始搜索。这就解释了为什么它错误地返回了0——因为它没有从预期的起点开始搜索。

## 修改 `findSmallest` 方法

为了解决这个问题，我们对 `findSmallest` 方法进行了修改，让它能够接受一个起始索引，并从这个索引开始搜索数组中的最小元素。这样，它就可以正确地从任意给定的起点开始操作，而不是总是从数组的最开始搜索。

## 重新测试 `findSmallest`

修改 `findSmallest` 方法后，为了确保修改没有引入新的错误，我们重新运行了对应的测试。特别是，我们更新了测试用例以反映从数组的不同位置开始搜索的需求。通过这些修改后的测试，我们能够验证 `findSmallest` 现在能够正确地从指定的起点开始搜索最小元素。

## 整体测试排序算法

一旦 `findSmallest` 方法的修改被验证为正确，我们继续运行整体的排序算法测试。这些测试帮助我们确认整个排序流程现在能够按预期工作。我们可以通过增加更多的测试用例来进一步检验排序算法的健壮性和准确性。

## 反思调试和测试的重要性

整个过程强调了测试在开发中的重要性。通过构建和运行详尽的测试，我们能够逐步验证每一个变更，确保每个功能块都能正常工作。此外，当问题出现时，拥有有效的测试可以帮助我们快速定位问题，并有针对性地调整代码。

通过这一系列的调试和测试，我们成功地修复了代码中的错误，并优化了算法的实现。这个过程不仅提高了代码的质量，也增強了我们对代码行为的理解。调试是开发中一项至关重要的技能，而构建有效的测试则是确保代码质量和功能正确性的关键。

## 完成排序功能的开发

至此，我们已经完成了排序方法的开发。在实际应用中，我们会为排序方法构建更为全面的测试套件，而不仅仅是进行单一的调用测试。但在今天的61b课程中，我们将此视为一个阶段的完成。

## 反思开发过程

我们的开发过程是渐进的，常常需要在思考完全不同的事项之间切换，甚至在工作过程中对项目的整体设计进行更改。这种情况在我们开发排序方法时就已显现：我们不得不彻底改变 `findSmallest` 方法的签名，并确保它的有效运作，这在开发中是很常见的情况。

## 测试的重要性

测试提供了一种方式，使我们不必同时记住太多信息。它们像是大脑的支架，让我们可以安全地“放置”思考的内容，而不必承担全部负担。例如，通过 `testSort`，我们可以暂时专注于 `findSmallest`，解决问题后再回到原本的上下文——即继续开发排序方法。这种方法不仅便于在不同的上下文之间切换，还为代码提供了稳定性，确保了基本组件的正常工作。

## 测试提供的稳定性和可重构性

有了这些基础测试，我们就能确信代码的基本部分是可靠的，这为程序的其余部分提供了坚实的基础。如果需要在代码中进行更改，这些测试能够帮助我们检测并指出任何故障。此外，测试还支持代码的重构——即对代码进行修改以提高效率或可读性，同时确保功能保持不变。这种能力使我们能够尝试不同的实现方法（如使用 `findLargest` 而非 `findSmallest`），并在更大的项目中灵活地修改或优化代码。

## 测试在更大项目中的作用

在即将到来的第二个项目中，你将发现需要重新编写许多代码部分，可能是因为某些想法在根本上有缺陷，或者原有的实现方式效率不高。在这种情况下，为各个部件编写的测试将极大地简化重构过程，确保程序整体的功能性和一致性。

## 接下来的步骤

尽管我们已经完成了排序方法的基本开发和测试，但关于如何管理和执行这些测试还存在一些问题，例如频繁地注释或取消注释测试代码。在下一个视频中，我将进一步探讨如何优化测试执行过程，使其更加高效和便捷。